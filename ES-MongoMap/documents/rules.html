<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<title>MongoMap: Rules</title>
	 <style type="text/css">
 		body {
 			font-family: arial; sans;
 			font-size: 14pt;
	 		counter-reset: figures;
 		}
 		
		figure {
			counter-increment: figures;
		}

		figure figcaption:before {
			content: 'Figure ' counter(figures) ': ';
		}
 	</style>
</head>

<body class="article">

<h1>MongoMap Rules</h1>

<h2>Rule 1: Database to MongoDB db</h2>
<p>
Database in the context of SQL metamodel and not SQL metamodel is a systematic collection of data; therefore a SQL database is transformed into MongoDB database.
</p>

<h2>Rule 2: Table to Collection</h2>
<p>
In a SQL database a table is simply a collection of zero or more rows while in MongoDB a collection is a grouping of MongoDB documents. See next figure. 
</p>

<figure>
	<img src="table-row_Sql_Mongo.png"/>
	<figcaption>Mapping of Table to Collection and Row to Document</figcaption>
</figure>

<h2>Rule 3: Row to Document</h2>
<p>
In SQL database a row represents a single, implicitly structured data item in a table while in MongoDB a document is a record in a MongoDB collection. See the figure above. 
</p>


<h2>Rule 4 : Cell to Value</h2>

<p>
In SQL, each table consist of a collection of columns/fields and all those columns together are used to represent an instance of the table (row/record/tuple). For example, in a table that represents users, each row would represent a single user. Columns might represent things like user name, user age, etc. Cells in the same row are identified by the column name: 
</p>

<figure>
	<img src="userTable.jpg"/>
	<figcaption></figcaption>
</figure>
<p>
In Fig1, the first row is selected, which consists of several cells, and then column name is used to select/return only one cell. In this case, column is name and cell value is Sara.
In MongoDB, each collection consist of a group of documents, documents like rows have many field:value or key:values. Key is like column names in SQL and value is like cell values.
</p>

<figure>
	<img src="insert.jpg"/>
	<figcaption></figcaption>
</figure>

<h2>Rule 5: Primary-Key/Composite-Key</h2>
<p>
<h3>5.A: Primary Key</h3>
<p>
_id in mongo DS is the default primary key which can be overwritten.  It is unique by default. The values of  primary key from SQL database will be copied to MongoDB as Values in Key value pair where key is “_id.”
</p >
<figure>
	<img src="sampletable.png"/>
	<figcaption>Sample table</figcaption>
</figure>

<p>
<figure>
	<img src="idmongo.png"/>
	<figcaption>Mapping Primary key to the value of _id</figcaption>
</figure>



<h3>5.B: Composite Key </h3>

<p>
A composite primary key will be mapped to a subdocument which is the value of _id. The _id key is the default identifier of a document and has per default an unique index. The columns (and the corresponding cells of each row) of a composite key will be stored in the subdocument. Using a subdocument rather than multiple key-value-pairs in the parent document has the advantage that the creation of foreign keys is easier because only _ id needs to be referenced. Moreover, this solution keeps the columns of composite key semantically together.
</p>

<figure>
	<img src="composite-key-to-_id-subdocument.png"/>
	<figcaption>Mapping of Composite-Primary-Key to _id with subdocument</figcaption>
</figure>

<h2>Rule 6: Unique-Constraint to UniqueIndex</h2>
<p>
The Unique-Constraint object will be mapped to an UniqueIndex object. The relationships to the unique columns will be mapped to an array of strings. We decided to do it like this because there is no real schema (e.g. columns) in MongoDB. Hence, every document of a collection can have different key-value-pairs. Moreover, an index can be added to keys which do not exist yet in any document of the collection.
</p id="rule8_img">

<figure>
	<img src="constraint-to-uniqueindex.png"/>
	<figcaption>Mapping of Unique-Constraint instance (left) to UniqueIndex instance (right)</figcaption>
</figure>

</body>

</html>
